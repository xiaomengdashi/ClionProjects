# Prototype Pattern（原型模式）

## 概述
原型模式是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类。原型模式用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

## 意图
- 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
- 在运行时指定要实例化的类

## 结构
1. **Prototype（原型）**：声明一个克隆自身的接口
2. **ConcretePrototype（具体原型）**：实现一个克隆自身的操作
3. **Client（客户端）**：让一个原型克隆自身从而创建一个新的对象

## 适用场景
- 当要实例化的类是在运行时刻指定时
- 为了避免创建一个与产品类层次平行的工厂类层次时
- 当一个类的实例只能有几个不同状态组合中的一种时
- 创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等

## 优点
- 性能提高：避免了重新初始化对象，而是动态地获得对象运行时的状态
- 逃避构造函数的约束：这既是它的优点也是缺点，直接在内存上拷贝，构造函数是不会执行的

## 缺点
- 配备克隆方法需要对类的功能进行通盘考虑
- 对于已有的类不容易提供克隆方法
- 实现深拷贝时可能需要比较复杂的代码

## 深拷贝 vs 浅拷贝
- **浅拷贝**：只复制对象的基本类型字段，对于引用类型字段只复制引用
- **深拷贝**：不仅复制对象的基本类型字段，还递归复制引用类型字段指向的对象

## 实现要点
1. **clone()方法**：核心方法，用于复制对象
2. **拷贝构造函数**：通常需要实现拷贝构造函数来支持克隆
3. **内存管理**：注意智能指针的使用，避免内存泄漏

## 编译和运行
```bash
# 创建测试文件
cat > prototype_test.cpp << 'EOF'
#include "prototype.hpp"

int main() {
    prototype_test();
    return 0;
}
EOF

# 编译运行
g++ -std=c++14 prototype_test.cpp -o prototype_test
./prototype_test
```

## 示例输出
```
=========prototype test==========
ConcretePrototypeA
ConcretePrototypeB
ConcretePrototypeA
ConcretePrototypeB
del ConcretePrototypeA
del ConcretePrototypeB
del ConcretePrototypeB
del ConcretePrototypeA
```

## 实际应用示例
- **图形编辑器**：复制图形对象
- **游戏开发**：复制游戏角色或道具
- **文档处理**：复制文档模板
- **数据库连接**：复制数据库连接配置

## 注意事项
- 本实现中的测试函数使用了裸指针，在实际项目中建议全部使用智能指针
- 克隆方法应该处理所有成员变量，包括深拷贝需要的复杂对象
- 考虑线程安全性，特别是在多线程环境中使用原型模式时