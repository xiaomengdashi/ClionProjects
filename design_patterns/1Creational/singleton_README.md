# Singleton Pattern（单例模式）

## 概述
单例模式是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

## 意图
- 保证一个类仅有一个实例，并提供一个访问它的全局访问点
- 控制实例数目，节省系统资源

## 结构
1. **Singleton（单例）**：定义一个getInstance操作，允许客户访问它的唯一实例

## 实现要点
1. **私有构造函数**：防止外部直接创建实例
2. **删除拷贝构造函数和赋值操作符**：防止复制实例
3. **静态getInstance方法**：提供全局访问点
4. **线程安全**：使用局部静态变量实现线程安全的懒汉式单例

## 适用场景
- 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时
- 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时
- 控制资源的使用，例如线程池、缓存、日志对象等

## 优点
- 提供了对唯一实例的受控访问
- 缩小名空间
- 允许对操作和表示的精化
- 允许可变数目的实例
- 比类操作更灵活

## 缺点
- 单例模式一般没有接口，扩展困难
- 单例模式对测试不利
- 单例模式与单一职责原则冲突

## 实现方式
本实现使用了**懒汉式单例**（Lazy Initialization）：
- 使用局部静态变量，在C++11及以后版本中保证线程安全
- 第一次调用getInstance()时才创建实例
- 程序结束时自动销毁

## 编译和运行
```bash
# 创建测试文件
cat > singleton_test.cpp << 'EOF'
#include "singleton.hpp"

int main() {
    singleton_test();
    return 0;
}
EOF

# 编译运行
g++ -std=c++14 singleton_test.cpp -o singleton_test
./singleton_test
```

## 示例输出
```
=========singleton test==========
Both instances are the same.
Singleton is doing something.
```

## 其他实现方式
1. **饿汉式单例**：程序启动时就创建实例
2. **双重检查锁定**：在多线程环境中的优化实现
3. **使用std::once_flag**：更现代的C++实现方式