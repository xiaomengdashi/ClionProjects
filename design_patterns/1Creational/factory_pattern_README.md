# Factory Method Pattern（工厂方法模式）

## 概述
工厂方法模式是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。

## 意图
- 定义一个用于创建对象的接口，让子类决定实例化哪一个类
- 工厂方法使一个类的实例化延迟到其子类

## 结构
1. **Product（产品）**：定义工厂方法所创建的对象的接口
2. **ConcreteProduct（具体产品）**：实现Product接口
3. **Creator（创建者）**：声明工厂方法，该方法返回一个Product类型的对象
4. **ConcreteCreator（具体创建者）**：重定义工厂方法以返回一个ConcreteProduct实例

## 适用场景
- 当一个类不知道它所必须创建的对象的类的时候
- 当一个类希望由它的子类来指定它所创建的对象的时候
- 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候

## 优点
- 良好的封装性，代码结构清晰
- 扩展性非常好
- 屏蔽产品类
- 典型的解耦框架

## 缺点
- 产品类数目较多时，需要大量的工厂类，增加了代码的复杂性
- 增加了系统的抽象性和理解难度
- 抽象产品只能生产一种产品

## 与简单工厂模式的区别
- **简单工厂模式**：用一个工厂类来创建所有产品
- **工厂方法模式**：每个产品都有对应的工厂类

## 与抽象工厂模式的区别
- **工厂方法模式**：针对一个产品等级结构
- **抽象工厂模式**：针对多个产品等级结构

## 编译和运行
```bash
# 创建测试文件
cat > factory_test.cpp << 'EOF'
#include "factory_pattern.hpp"

int main() {
    factory_test();
    return 0;
}
EOF

# 编译运行
g++ -std=c++14 factory_test.cpp -o factory_test
./factory_test
```

## 示例输出
```
=========strategy test==========
ConcreteProductA operation
ConcreteProductB operation
```

## 实际应用示例
- **日志记录器**：不同的日志记录方式（文件、数据库、网络）
- **数据库访问**：不同的数据库类型（MySQL、PostgreSQL、SQLite）
- **UI组件**：不同平台的UI控件创建